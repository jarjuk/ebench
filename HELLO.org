
* Basic hello  world

** Imports
   :PROPERTIES:
   :header-args:bash: :dir  examples/hello
   :END:


 #+name: import
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 import ebench
 from ebench import MenuCtrl
 #+END_SRC

 #+RESULTS: import
 : Python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42) 
 : [GCC 9.3.0] on linux
 : Type "help", "copyright", "credits" or "license" for more information.

 #+name: import-env
 #+BEGIN_SRC python :eval no-export :results output :noweb no :session *Python*
 import os
 from absl import app, flags, logging
 from absl.flags import FLAGS
 #+END_SRC

 #+RESULTS: import-env


** Define hello

Define Python function hello, which accepts parameter, whom is being
greeted.

 #+name: hello
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 def hello( whom:str ):
     print( "Hello {}".format(whom))
 #+END_SRC


Define dictionary, which maps function parameters to promts. In this
case, ~hello~ -function has one parameter ~whom~, which needs to be
prompted.

 #+name: helloPar
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 helloPar = {
    "whom": "Whom to greet?"
 }
 #+END_SRC


** Define menu

Define a menu strcuture, which maps command "hello" to a 3-tuple of
consisinting proproment, name parameter prompts dictionanary, and
function pointer.

 #+name: menu
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

     mainMenu = {
         "hello"                 : ( "Say hello", helloPar, hello),
         MenuCtrl.MENU_QUIT      : ( "Exit", None, None),
     }
 #+END_SRC

#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
import ebench
import textwrap

# print(textwrap.dedent(ebench.MenuCtrl.mainMenu.__doc__))
print(ebench.MenuCtrl.mainMenu.__doc__)
#+END_SRC

#+RESULTS:
#+begin_example
For interactive usage, prompt user for menu command and command
        paramaters, for command line usage parse commands and
        parameters from '_argv'. Invoke action for command.

        :_argv: command line paramaters (in batch mode)

        :mainMenu: dict mapping menuCommand:str -> menuSelection =
        List[menuPrompt,parameterPrompt,menuAction], where
        - menuPrompt: string presented to user to query for
          'commandParameter' value
        - parameterPrompt: dict mapping 'commandParameter' name to
          commandParameter prompt
        - menuAction: function to call with 'commandParameters' (as
          ,**argv values prompted with parameterPrompt)

        :defaults: is dictionary mapping 'menuCommand' to
        'defaultParameters'.  If 'defaultParameters' for a
        'menuCommand' is found, it is used to lookup 'defaultValue'
        prompeted from user. Also, If 'defaultParameters' for a
        'menuCommand' is found, 'defaultParameters' update with the
        value user enters for the promt.
#+end_example



** define =_main=

 #+name: _main
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes
 def _main( _argv ):
     # global gSkooppi
     logging.set_verbosity(FLAGS.debug)

     cmdController = MenuCtrl(args=_argv,prompt="[hello, q=quit]")
     cmdController.setMenu(mainMenu)

     cmdController.mainMenu()

    

 #+END_SRC

 #+RESULTS: _main


** define script ~main~

 #+name: main
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

 def main():
     try:
         app.run(_main)
     except SystemExit:
         pass
    
    
 if __name__ == '__main__':
     main()

 #+END_SRC


** Hello.py


 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello/hello.py :noweb yes :shebang "#!/usr/bin/env python3"
 <<import>>

 <<import-env>>

 <<hello>>

 <<helloPar>>

 <<menu>>

 <<_main>>

 <<main>>

 #+END_SRC

#+BEGIN_SRC bash :eval no :results output
cat examples/hello/hello.py
#+END_SRC

#+RESULTS:
#+begin_example
#!/usr/bin/env python3
import ebench
from ebench import MenuCtrl



import os
from absl import app, flags, logging
from absl.flags import FLAGS

def hello( whom:str ):
    print( "Hello {}".format(whom))

helloPar = {
   "whom": "Whom to greet?"
}


mainMenu = {
    "hello"                 : ( "Say hello", helloPar, hello),
    MenuCtrl.MENU_QUIT      : ( "Exit", None, None),
}

def _main( _argv ):
    # global gSkooppi
    logging.set_verbosity(FLAGS.debug)

    cmdController = MenuCtrl()

    cmdController.mainMenu( _argv, menu=mainMenu, mainPrompt="[hello, q=quit]")






def main():
    try:
        app.run(_main)
    except SystemExit:
        pass


if __name__ == '__main__':
    main()
#+end_example


** =hello= interctive usage

Interactive usage demonstraded using HERE-document. 

#+BEGIN_SRC bash :eval no-export :results output
  cat <<EOF | examples/hello/hello.py
  hello
  moon
  q
  EOF
#+END_SRC

#+RESULTS:
: [hello, q=quit] > Whom to greet? > Hello moon
: [hello, q=quit] > 


** =hello= CLI usage

Pass parameters on command line

#+BEGIN_SRC bash :eval no-export :results output :exports both
examples/hello/hello.py hello whom=World
#+END_SRC

#+RESULTS:
: Hello World



* Hello extended 

Second hello version, ~hello2~ presents:
- help to list commands and to present usage help
- more detailed help on menu commands
- menu structuring using menu separator
- hiding menu command from menu command list
- default value for menu command parameter
- proviso to integrate ~hello2~ to menu system

** Hello2

Import ~Instrument~ class from ~ebench~

 #+name: import2a
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 from ebench import Instrument
 #+END_SRC

and use it to derive ~HelloInstrument~ class. ~HelloInstrument~ counts
number of greets made in variable ~greetCount~.  Method ~sayHello~
prints out greeting and increments ~greetCount~.

 #+name: hello2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
   class HelloInstrument(Instrument):

     def __init__(self, greetCount=0):
         self._greetCount = greetCount

     def greetCount(self, fake=0 ):
         """Access object state variable with API twist

         :fake: parameter used to demonstrate passing named parameter
         value in API call

         :return: current 'greetCount' + 'fake'

         """

         return self._greetCount + int(fake)

     def sayHello( self, whom:str, who:str ):
         """Hello -command just demonstrates simple menu action.

         It receives to parameters 'whom' and 'who' and prints
         greeting. Defaulta value of 'who' parameter is logged user, and
         its value is remembered between hello commands

         Returns greeted 'whom' if greeter/who is not the same as
         greeted/whom.

         Incrementing greetCount demonstrates that Intrument MAY
         maintain internal state.

         """
         self._greetCount = self._greetCount + 1
         print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))
 #+END_SRC


** Menu acttion parameter with default value

Dictionary ~helloPar~ names the the paramerters ~sayHello~ methods
accepts, and maps these variable names from prompt string presented to
user.

 #+name: helloPar2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 helloPar = {
    "whom": "Whom to greet?",
    "who":  "Who is the greeter? Ret accepts default value: ",
 }
 #+END_SRC


Dictionary ~defaults~ is used to provide default values to menu
paramters. In this example, hello menu selection parameter ~who~ gets
default value from environment variable ~$USER~.

#+name: defaults
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

defaults = {
"hello" : {
             "who": os.environ['USER']
          }
}
#+END_SRC


** List commands and help commands 

Import ~usage~ and ~usageCommand~ for presenting usage insrtuctions
and help on menu selections.

 #+name: import2b
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 from ebench import usage, usageCommand
 #+END_SRC


Define application usage text. For this example we will define
variable ~usageText~

#+name:usageText
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

  usageText = """

  This demo presents:

  - command 'hello' accepting two parameters, one of the parameters
    (whom) is prompted for every command call, the other paremeter (who)
    defaults to to login-name, and its value is rememebered from
    previous call

  - menu separator

  - help to list command (and to show this text)

  - more detailed help on menu commands

  - hidden command: _version

  """


#+END_SRC


** Define application menu

Hello menu2 is presented in three sections:

 #+name: menu2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
   mainMenu = {

       # First section: application commands
       "Commands:"              : ( None, None, None),
       "hello"                  : ( "Say hello", helloPar, hello.sayHello ),

       # Second section: getting help
       "Help:"                  : ( None, None, None),
       MenuCtrl.MENU_HELP       : ( "List commands", None,
                                  lambda : usage(cmd=os.path.basename(__file__)
                                                       , mainMenu=mainMenu
                                                       , synopsis="Demo hello v2"
                                                       , usageText=usageText )),
       MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                  lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),
       "_version"               : ("Version number", None, lambda **argv: print(ebench.version())),

       # Third section: exiting
       "Exit:"                  : ( None, None, None),
       MenuCtrl.MENU_QUIT       : ("Exit", None, None),

   }

 #+END_SRC


** Running application

Application ~_main~ calls ~run~ method, which instantiates
~HelloInstrument~, application menu and creates ~menuController~,
which executes application REPL (red-eval-print) -loop

*Note*: proviso for intergrating ~hello2~ to ~ebMenu~ application
- ~run~ method will be called by ~ebMenu~ application to contruct menu
  controller for application being integrated
- ~run~ -method uses boolean parameter ~runMenu~ guarding
  ~menuController.mainMenu()~ statement
- closing menu ~menuController~ is done in ~_main~


#+name: _main2
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes

def run( _argv, runMenu:bool = True, greetCount = 0  ):
     hello = HelloInstrument( greetCount = greetCount )

     <<menu2>>

     menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]", instrument=hello )
     menuController.setMenu(menu=mainMenu, defaults=defaults)
     if runMenu: menuController.mainMenu()

     return menuController


def _main( _argv ):
     # global gSkooppi
    logging.set_verbosity(FLAGS.debug)
    menuController = run( _argv )
    menuController.close()




 #+END_SRC

 #+RESULTS: _main


** hello2 application 

 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello/hello2.py :noweb yes :shebang "#!/usr/bin/env python3"
 <<import>>
 <<import2a>>

 <<import2b>>

 <<import-env>>

 # --------------------------------------
 # Example instrument "HelloInstrument"

 <<hello2>>

 # --------------------------------------
 # Menu interagration

 <<helloPar2>>

 <<defaults>>

 <<helpers>>

 <<usageText>>

 # --------------------------------------
 # Application main && ebMenu integration

 <<_main2>>

 <<main>>

 #+END_SRC



** Running it

*** Usage help and listing commands with =?=
#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py ?
#+END_SRC

#+RESULTS:
#+begin_example
hello2.py: Demo hello v2

Usage: hello2.py [options] [commands and parameters] 

Commands:

---------- Commands:  ----------
          hello  : Say hello
----------   Help:    ----------
              ?  : List commands
             ??  : List command parameters
----------   Exit:    ----------
              q  : Exit


This demo presents:

- command 'hello'  acceting two parameters, one of the parameters (whom) is
  prompted for every command call, the other paremeter (who) defaults to 
  to login-name, and its value is rememebered from previous call

- menu separator

- help to list command

- help on command parameters

- hidden command: _version


#+end_example

*** Hidden commands

Notice command ~_version~ is not show in commands list presented in
previous chapter. However, running

#+name: hello2-version
#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py _version
#+END_SRC

outputs version number of ebench -application

#+RESULTS: hello2-version
: 0.0.10-SNAPSHOT



*** Help on a specific command: =??=


#+BEGIN_SRC bash :eval no :results output
examples/hello/hello2.py ?? command=hello
#+END_SRC

#+RESULTS:
#+begin_example
hello - Say hello

Hello -command just demonstrates simple menu action.

It receives to parameters 'whom' and 'who' and prints
greeting. Defaulta value of 'who' parameter is logged user,
and its value is remembered between hello commands

Returns greeted 'whom' if greeter/who is not the same as
greeted/whom.

Notice, how

      whom  : Whom to greet?
       who  : Who is the greeter? Ret accepts default value: 

Notice:
- parameters MUST be given in the order listed above
- parameters are optional and they MAY be left out
#+end_example


*** Default value of a parater

Expect to see 'Hello world from $USER', where user gets default value
from environment variable.

#+BEGIN_SRC bash :eval no-export :results output
echo USER=$USER
examples/hello/hello2.py hello whom="world" 
#+END_SRC

#+RESULTS:
: USER=jj
: Hello 1 world from jj

Expect to see 'Hello world from moon', where default value is
overridden on command line.

#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py hello whom="world" who="moon"
#+END_SRC

#+RESULTS:
: Hello 1 world from moon


*** Object state is managed and parameter values are remembered

Greeting twice, demostrates how object state gets in maintained
(variable ~greetCount~ increment for each greeting ), for ~hello2~
execution. Thi example also shows, how, for the second greeting,
variable ~who~ retains its previous value given to the first greeting.

#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py hello whom="world" who="earth" hello whom="sun"
#+END_SRC

#+RESULTS:
: Hello 1 world from earth
: Hello 2 sun from earth


* Fin                                                              :noexport:

** Emacs variables

   #+RESULTS:

   # Local Variables:
   # org-confirm-babel-evaluate: nil
   # End:
   #
   # Muuta 
   # eval: (cdlatex-mode)
   #
   # Local ebib:
   # org-ref-default-bibliography: "./HELLO.bib"
   # org-ref-bibliography-notes: "./HELLO-notes.org"
   # org-ref-pdf-directory: "./pdf/"
   # org-ref-notes-directory: "."
   # bibtex-completion-notes-path: "./HELLO-notes.org"
   # ebib-preload-bib-files: ("./HELLO.bib")
   # ebib-notes-file: ("./HELLO-notes.org")
   # reftex-default-bibliography: ("./HELLO.bib")



