* Hello World
:PROPERTIES:
:TOC:      :include all
:END:

This document presents two hello world examples:
1) Stand alone Hello World
2) Hello World as an instrument controller, which can be integrated
   with other instrument controllers to ~ebMenu~

:CONTENTS:
- [[#hello-world][Hello World]]
  - [[#stand-alone-hello-world---hellopy][Stand Alone Hello World - hello.py]]
    - [[#imports][Imports]]
    - [[#define-hello--function-and-parameter-prompt][Define hello -function and parameter prompt]]
    - [[#define-menu][Define menu]]
    - [[#wrap-hello-to-an-executable-script][Wrap hello to an executable script]]
    - [[#complete-hellopy][Complete hello.py]]
    - [[#runnig-hellopy][Runnig hello.py]]
      - [[#hello-interctive-usage][hello interctive usage]]
      - [[#hello-cli-usage][hello CLI usage]]
  - [[#hello-world-as-an-instrument-controller---hello2py][Hello World as an Instrument Controller - hello2.py]]
    - [[#define-instrument-controller-class--helloinstrument][Define Instrument Controller Class  HelloInstrument]]
    - [[#define-parameters-and-default-values-for-menu-action-hello][Define parameters and default values for menu action hello]]
    - [[#list-commands-and-help-commands][List commands and help commands]]
    - [[#define-application-menu][Define application menu]]
    - [[#create--run--function-for-executing-the-application][Create  run -Function for executing the application]]
    - [[#interactive-and-cli--entry-point-in-hello2_mainpy][Interactive and CLI -entry point in hello2_main.py]]
    - [[#hello2-application][hello2 application]]
      - [[#hello2py][hello2.py]]
      - [[#hello2_mainpy][hello2_main.py]]
      - [[#__init__py-and-directory-list][__init__.py and directory list]]
    - [[#running-hello2][Running hello2]]
      - [[#configuration-parameters-with---help][Configuration parameters with --help]]
      - [[#usage-help-and-listing-commands-with-][Usage help and listing commands with ?]]
      - [[#hidden-commands][Hidden commands]]
      - [[#help-on-a-specific-command-][Help on a specific command: ??]]
      - [[#default-value-of-a-parameter][Default value of a parameter]]
      - [[#object-state-is-managed-and-parameter-values-are-remembered][Object state is managed and parameter values are remembered]]
      - [[#use-command-line-configuration-for-intialization][Use command line configuration for intialization]]
:END:


** Stand Alone Hello World - ~hello.py~

*** Imports
    :PROPERTIES:
    :header-args:bash: :dir  examples/hello
    :END:

 Hello -example uses ~MenuCtrl~ class from ~ebench~ module

  #+name: import
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from ebench import MenuCtrl
  #+END_SRC

  #+RESULTS: import
  : Python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42) 
  : [GCC 9.3.0] on linux
  : Type "help", "copyright", "credits" or "license" for more information.

 and some basic infrastructure services from ~os~ module and command
 line options from ~absl~

  #+name: import-env
  #+BEGIN_SRC python :eval no-export :results output :noweb no :session *Python*
  import os
  from absl import app, flags, logging
  from absl.flags import FLAGS
  #+END_SRC

  #+RESULTS: import-env


*** Define ~hello~ -function and parameter prompt

 Define Python function ~hello~ with a parameter ~whom~, which gives
 whom to greet:

  #+name: hello
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  def hello( whom:str ):
      print( "Hello {}".format(whom))
  #+END_SRC

 For prompting ~"Whom to greet?"~ define a dictionary, which maps
 ~whom~ parameter to a promp presented to user in menu REPL -loop:

  #+name: helloPar
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  helloPar = {
     "whom": "Whom to greet?"
  }
  #+END_SRC



*** Define menu

 Define a menu command for invoking ~hello~ function and allowing user
 to quit the appplication with menu command ~MenuCtrl.MENU_QUIT~
 (mapped to letter ~q~).

 Menu is defined as dictionary mapping menu command to a 3-tuple. The
 tuple elements are 0: /prompt presented to user/, 1: /menu action
 parameters/, and 3: /function to execute the menu action/.

  #+name: menu
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

      mainMenu = {
          "hello"                 : ( "Say hello", helloPar, hello),
          MenuCtrl.MENU_QUIT      : MenuCtrl.MENU_QUIT_TUPLE,
      }
  #+END_SRC


*** Wrap hello to an executable script

 To create an executable script first define function ~_main~, which
 constructs ~MenuCtrl~ object and configures main prompt presented to
 user. Passing ~_arvg~ parameter to constructor allows application
 interactive and CLI usage.  Method ~setMenu~ configures menu presented
 user and application REPL cycle is executed within ~mainMenu()~
 -method.

  #+name: _main
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes
  def _main( _argv ):
      # configure logger
      logging.set_verbosity(FLAGS.debug)

      # Construct 'menuController' 
      menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]")
     
      # and configure menu
      menuController.setMenu(mainMenu)

      # start executing
      menuController.mainMenu()

  #+END_SRC

 Finalize application with following code, which basically calls
 ~_main~ after absl context is setup correctly.

  #+name: main
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  def main():
      try:
          app.run(_main)
      except SystemExit:
          pass
    
    
  if __name__ == '__main__':
      main()

  #+END_SRC


*** Complete ~hello.py~

  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello/hello.py :noweb yes :shebang "#!/usr/bin/env python3" :exports none
  <<import>>

  <<import-env>>

  <<hello>>

  <<helloPar>>

  <<menu>>

  <<_main>>

  <<main>>

  #+END_SRC

 Complete ~hello~ example is shown below:

 #+BEGIN_SRC bash :eval no :results output :exports results
 cat examples/hello/hello.py
 #+END_SRC

 #+RESULTS:
 #+begin_example
 #!/usr/bin/env python3
 import ebench
 from ebench import MenuCtrl



 import os
 from absl import app, flags, logging
 from absl.flags import FLAGS

 def hello( whom:str ):
     print( "Hello {}".format(whom))

 helloPar = {
    "whom": "Whom to greet?"
 }


 mainMenu = {
     "hello"                 : ( "Say hello", helloPar, hello),
     MenuCtrl.MENU_QUIT      : ( "Exit", None, None),
 }

 def _main( _argv ):
     # global gSkooppi
     logging.set_verbosity(FLAGS.debug)

     cmdController = MenuCtrl()

     cmdController.mainMenu( _argv, menu=mainMenu, mainPrompt="[hello, q=quit]")






 def main():
     try:
         app.run(_main)
     except SystemExit:
         pass


 if __name__ == '__main__':
     main()
 #+end_example


*** Runnig ~hello.py~

**** =hello= interctive usage

  Interactive usage demonstrated using HERE-document. The following
  example prompts user whom to greet, and after the answer, ~moon~,
  greets the moon.

  #+BEGIN_SRC bash :eval no-export :results output :exports both
    cat <<EOF | examples/hello/hello.py
    hello
    moon
    q
    EOF
  #+END_SRC

  #+RESULTS:
  : [hello, q=quit] > Whom to greet? > Hello moon
  : [hello, q=quit] > 


**** =hello= CLI usage

  for Command line usage, menu command 'hello' is followed by key-value
  pair ~whom=World~. The result greets the world.

  #+BEGIN_SRC bash :eval no-export :results output :exports both
  examples/hello/hello.py hello whom=World
  #+END_SRC

  #+RESULTS:
  : Hello World


  :PROPERTIES:
  :TOC:      :include all
  :END:

  :CONTENTS:

  :END:


** Hello World as an Instrument Controller - ~hello2.py~ 

 Second Hello World  -version, ~hello2~, presents:
 - maintaining instrument state (in this example count number of greets
   made)
 - help to list commands 
 - more detailed help on menu commands
 - menu structuring using menu separator
 - hiding menu command from menu command list
 - default value for menu command parameter
 - proviso to integrate ~hello2~ to menu system ~ebMenu~ (ref
   [[file:EBMENU.org]])

*** Define Instrument Controller Class  ~HelloInstrument~

 Add import for  ~Instrument~ class from ~ebench~:

  #+name: import2a
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from ebench import Instrument
  #+END_SRC

 and use it to derive ~HelloInstrument~ class. ~HelloInstrument~ counts
 number of greets made in variable ~greetCount~. Its initial value can
 be set in constructor.  Method ~sayHello~ prints out greeting and
 increments number of greets made in ~greetCount~.

  #+name: hello2
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
    class HelloInstrument(Instrument):

      def __init__(self, greetCount=0):
          self._greetCount = greetCount

      def greetCount(self, fake=0 ):
          """Access object state variable with API twist

          :fake: parameter used to demonstrate passing literal parameter
          value in API call

          :return: current 'greetCount' + 'fake'

          """

          return self._greetCount + int(fake)

      def sayHello( self, whom:str, who:str ):
          """Hello -command just demonstrates simple menu action.

          It receives to parameters 'whom' and 'who' and prints greeting
          and increments 'greetCount' (just to demonstrate that Intrument
          MAY maintain internal state).


          :who: default value is of 'who' parameter is logged in user, its
          value is remembered between greetings

          :whom: object to be greeted

          """
          self._greetCount = self._greetCount + 1
          print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))
  #+END_SRC


*** Define parameters and default values for menu action ~hello~

 Dictionary ~helloPar~ names the the paramerters ~sayHello~ methods
 accepts, and maps these variable names from prompt string presented to
 user.

  #+name: helloPar2
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  greetPar = {
     "whom": "Whom to greet?",
     "who":  "Who is the greeter? Ret accepts default value: ",
  }
  #+END_SRC


 Dictionary ~defaults~ is used to provide default values to menu
 parameters. In this example, hello menu selection parameter ~who~ gets
 default value from environment variable ~$USER~.

 #+name: defaults
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

 defaults = {
 "greet" : {
              "who": os.environ['USER']
           }
 }
 #+END_SRC


*** List commands and help commands 

 Import ~usage~ and ~usageCommand~ from ~ebench~ -module for
 presenting usage help.

  #+name: import2b
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from ebench import usage, usageCommand, version
  #+END_SRC


 Define variable ~usageText~ with text documenting ~hello2~
 application in general.

 #+name:usageText
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

   usageText = """

   This demo presents:

   - maintaining instrument state: counting number of greetings made

   - command 'hello' accepting two parameters, one of the parameters
     (whom) is prompted for every command call, the other paremeter (who)
     defaults to to login-name, and its value is rememebered from
     previous call

   - menu separator

   - help to list command (and to show this text)

   - more detailed help on menu commands

   - hidden command: _version

   - proviso for integrating ~hello2~ with ebMenu

   """


 #+END_SRC


*** Define application menu

 ~hello2~ -menu is divided into three sections 1) commands, 2) help,
 and 3) exiting:

  #+name: menu2
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
    mainMenu = {

        # First section: application commands
        "Commands:"              : MenuCtrl.MENU_SEPATOR_TUPLE,
        "greet"                  : ( "Say hello", greetPar, helloController.sayHello ),

        # Second section: getting help
        "Help:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
        MenuCtrl.MENU_HELP       : ( "List commands", None,
                                   lambda : usage(cmd=os.path.basename(__file__)
                                                        , mainMenu=mainMenu
                                                        , synopsis="Demo hello v2"
                                                        , usageText=usageText )),
        MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                   lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),

        # Third section: exiting
        "Exit:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
        MenuCtrl.MENU_QUIT       : MenuCtrl.MENU_QUIT_TUPLE,

        # Hidden
        "_version"               : ("Version number", None, lambda **argv: print(version())),
        # Line above makes following line visible
        # MenuCtrl.MENU_VERSION    : MenuCtrl.MENU_VERSION_TUPLE,
    }

  #+END_SRC


*** Create  ~run~ -Function for executing the application

 ~run~ -function instantiates ~HelloInstrument~, constructs
 ~menuController~, configures application ~mainMenu~ presented above
 (in the code snippet below ~mainMenu~ configuration is indicated with
 placeholder ~<<menu2>>~), and calls to ~menuController.mainMenu()~,
 which starts application [[https://codewith.mu/en/tutorials/1.1/repl][REPL]] (red-eval-print) -loop.

 In this example, ~outputTemplate~ is left to default value None, and
 menu actions are executed. Example [[file:GENTLE_SLOPE.org]] covers
 using ~outputTemplate~. 

 #+name: _run2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes

   def run( _argv, runMenu:bool = True, greetCount = 0, outputTemplate:str = None  ):
        """Run hello2 as a standalone interactive or CLI application with the
        proviso to integrate 'hello2' with ~ebench.ebMenu~ tool.

        :_argv: list of command line arguments. In interactive mode, this
        is just the name of script. In CLI mode, name is followed by
        command line arguments

        :runMenu: defaults True = running standalone application. ebMenu
        sets this to 'False'.

        :greetCount: In this contrived example, 'greetCount' is the
        number greetings already made. It is passed to 'HelloInstrument'
        -constructor. For real world use, 'greetCount' represents
        parameters needed in instruments constructor.

        :outputTemplate: controls how '_argv'/REPL input in processed,
        default None: they are executed, any other value is mapped to
        template to produce API reprensentation of menu actions. Here
        just pass it trough.

        """
        helloController = HelloInstrument( greetCount = greetCount )

        <<menu2>>

        menuController = MenuCtrl( args=_argv
                           , prompt="[hello, q=quit]"
                           , instrument=helloController
                           , outputTemplate=outputTemplate )
        menuController.setMenu(menu=mainMenu, defaults=defaults)
        if runMenu: menuController.mainMenu()

        return menuController

  #+END_SRC


*** Interactive and CLI -entry point in ~hello2_main.py~ 

Import ~hello2.run~ and some [[https://pypi.org/project/absl-py/][absl]] -services

#+name: hello2-import
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from hello2 import run

  from absl import app, flags, logging
  from absl.flags import FLAGS
#+END_SRC


DEfine command line configuration parameter ~greetCount~ with initial
value ~0~

#+name: hello2-configs
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  flags.DEFINE_integer('greetCount', 0, "Initial number of greets already made")
#+END_SRC

~_main~ calls ~hello.run()~ and passes command line configuration
parameter ~FLAGS.greetCount~ to the function. After returning from
~run~, close ~menuController~. 

 ~outputTemplate~ parameter is passed from command line option
~FLAGS.outputTemplate~.  Example [[file:GENTLE_SLOPE.org]] covers the
effect of using any other value than the default ~None~ for
~FLAGS.outputTemplate~.

 #+name: _main2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes

   def _main( _argv ):
       logging.set_verbosity(FLAGS.debug)

       # Start standalone application
       menuController = run( _argv, greetCount = FLAGS.greetCount, outputTemplate=FLAGS.outputTemplate )

       # q from menu or end of CLI parameters
       menuController.close()


  #+END_SRC

In ~main~ -function, setup ~absl~ context and call run ~_main()~
defined above:

#+name: _main2_main
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

  def main():
      try:
          app.run(_main)
      except SystemExit:
          pass
    
    
  if __name__ == '__main__':
      main()

#+END_SRC


*** hello2 application 

  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello2/hello2.py :noweb yes :shebang :exports none
  <<import>>

  <<import2a>>

  <<import2b>>

  import os

  # --------------------------------------
  # Example instrument "HelloInstrument"

  <<hello2>>

  # --------------------------------------
  # Menu interagration

  <<helloPar2>>

  <<defaults>>

  <<helpers>>

  <<usageText>>

  # --------------------------------------
  # Application run && ebMenu integration

  <<_run2>>

  #+END_SRC


  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello2/hello2_main.py :noweb yes :shebang "#!/usr/bin/env python3" :exports none

  <<hello2-import>> 

  # --------------------------------------
  # Command line configurations

  <<hello2-configs>> 

  # --------------------------------------
  # Application main - call hello2.run()

  <<_main2>>

  <<_main2_main>>


  #+END_SRC

  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello2/__init__.py :noweb yes :exports none
  #+END_SRC

 The complete hello2 implementation is presented in the following
 sections:

**** ~hello2.py~
  #+BEGIN_SRC bash :eval no-export :results output :exports results
  cat examples/hello2/hello2.py
  #+END_SRC

  #+RESULTS:
  #+begin_example
  from ebench import MenuCtrl

  from ebench import Instrument

  from ebench import usage, usageCommand, version

  import os
  from absl import app, flags, logging
  from absl.flags import FLAGS

  # --------------------------------------
  # Example instrument "HelloInstrument"

  class HelloInstrument(Instrument):

    def __init__(self, greetCount=0):
        self._greetCount = greetCount

    def greetCount(self, fake=0 ):
        """Access object state variable with API twist

        :fake: parameter used to demonstrate passing literal parameter
        value in API call

        :return: current 'greetCount' + 'fake'

        """

        return self._greetCount + int(fake)

    def sayHello( self, whom:str, who:str ):
        """Hello -command just demonstrates simple menu action.

        It receives to parameters 'whom' and 'who' and prints
        greeting. Defaulta value of 'who' parameter is logged user, and
        its value is remembered between hello commands

        Returns greeted 'whom' if greeter/who is not the same as
        greeted/whom.

        Incrementing greetCount demonstrates that Intrument MAY
        maintain internal state.

        """
        self._greetCount = self._greetCount + 1
        print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))

  # --------------------------------------
  # Menu interagration

  greetPar = {
     "whom": "Whom to greet?",
     "who":  "Who is the greeter? Ret accepts default value: ",
  }


  defaults = {
  "greet" : {
               "who": os.environ['USER']
            }
  }




  usageText = """

  This demo presents:

  - maintaining instrument state: counting number of greetings made

  - command 'hello' accepting two parameters, one of the parameters
    (whom) is prompted for every command call, the other paremeter (who)
    defaults to to login-name, and its value is rememebered from
    previous call

  - menu separator

  - help to list command (and to show this text)

  - more detailed help on menu commands

  - hidden command: _version

  - proviso for integrating ~hello2~ with ebMenu

  """



  # --------------------------------------
  # Application run && ebMenu integration


  def run( _argv, runMenu:bool = True, greetCount = 0  ):
       """Run hello2 as a standalone interactive or CLI application with the
       proviso to integrate 'hello2' with ~ebench.ebMenu~ tool.

       :_argv: list of command line arguments. In interactive mode, this
       is just the name of script. In CLI mode, name is followed by
       command line arguments

       :runMenu: defaults True = running standalone application. ebMenu
       sets this to 'False'.

       :greetCount: In this contrived example, 'greetCount' is the
       number greetings already made. It is passed to 'HelloInstrument'
       -constructor. For real world use, 'greetCount' represents
       parameters needed in instruments constructor.

       """
       helloController = HelloInstrument( greetCount = greetCount )

       mainMenu = {

           # First section: application commands
           "Commands:"              : MenuCtrl.MENU_SEPATOR_TUPLE,
           "greet"                  : ( "Say hello", greetPar, helloController.sayHello ),

           # Second section: getting help
           "Help:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
           MenuCtrl.MENU_HELP       : ( "List commands", None,
                                      lambda : usage(cmd=os.path.basename(__file__)
                                                           , mainMenu=mainMenu
                                                           , synopsis="Demo hello v2"
                                                           , usageText=usageText )),
           MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                      lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),
           "_version"               : ("Version number", None, lambda **argv: print(version())),

           # Third section: exiting
           "Exit:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
           MenuCtrl.MENU_QUIT       : MenuCtrl.MENU_QUIT_TUPLE,


       }


       menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]", instrument=helloController )
       menuController.setMenu(menu=mainMenu, defaults=defaults)
       if runMenu: menuController.mainMenu()

       return menuController
  #+end_example


**** ~hello2_main.py~

  Application main is saved into a separate file, ~hello2_main.py~, to
  avoid conflicts in ~absl~ flags in other applications.

  #+BEGIN_SRC bash :eval no-export :results output :exports results
  cat examples/hello2/hello2_main.py
  #+END_SRC

  #+RESULTS:
  #+begin_example
  #!/usr/bin/env python3
  from hello2 import run

  from absl import app, flags, logging
  from absl.flags import FLAGS 

  # --------------------------------------
  # Command line configurations

  flags.DEFINE_integer('greetCount', 0, "Initial number of greets already made") 

  # --------------------------------------
  # Application main - call hello2.run()


  def _main( _argv ):
      logging.set_verbosity(FLAGS.debug)

      # Start standalone application
      menuController = run( _argv, greetCount = FLAGS.greetCount )

      # q from menu or end of CLI parameters
      menuController.close()




  def main():
      try:
          app.run(_main)
      except SystemExit:
          pass


  if __name__ == '__main__':
      main()
  #+end_example


**** ~__init__.py~ and directory list

  Python requires an ~__init__.py~ -file to be saved along with
  ~hello2.py~ and ~hello2_main.py~

  #+BEGIN_SRC bash :eval no-export :results output :exports results
  cd examples/hello2
  ls -ltr | grep -v  __pycache__ | grep -v 'hello.yaml'
  #+END_SRC

  #+RESULTS:
  : total 24
  : -rw-rw-r-- 1 jj jj 4335 huhti 27 12:22 hello2.py
  : -rwxr-xr-x 1 jj jj  705 huhti 27 12:22 hello2_main.py
  : -rw-rw-r-- 1 jj jj    1 huhti 27 12:22 __init__.py


*** Running ~hello2~

In the examples below, ~<<hello2Cmd>>~ refers to following command:

#+name: hello2Cmd
#+BEGIN_SRC cpp :exports code
examples/hello2/hello2_main.py
#+END_SRC


**** Configuration parameters with ~--help~

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> --help
 #+END_SRC

 #+RESULTS:
 #+begin_example

        USAGE: examples/hello2/hello2_main.py [flags]
 flags:

 examples/hello2/hello2_main.py:
   --greetCount: Initial number of greets already made
     (default: '0')
     (an integer)

 Try --helpfull to get a list of all flags.
 #+end_example




**** Usage help and listing commands with =?=
 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> ?
 #+END_SRC

 #+RESULTS:
 #+begin_example
 hello2.py: Demo hello v2

 Usage: hello2.py [options] [commands and parameters] 

 Commands:

 ---------- Commands:  ----------
           greet  : Say hello
 ----------   Help:    ----------
               ?  : List commands
              ??  : List command parameters
 ----------   Exit:    ----------
               q  : Exit


 This demo presents:

 - maintaining instrument state: counting number of greetings made

 - command 'hello' accepting two parameters, one of the parameters
   (whom) is prompted for every command call, the other paremeter (who)
   defaults to to login-name, and its value is rememebered from
   previous call

 - menu separator

 - help to list command (and to show this text)

 - more detailed help on menu commands

 - hidden command: _version

 - proviso for integrating ~hello2~ with ebMenu


 #+end_example


**** Hidden commands

 Notice command ~_version~ is not show in commands list presented in
 previous chapter. However, running

 #+name: hello2-version
 #+BEGIN_SRC bash :eval no-export :results output :exports both :noweb yes
 <<hello2Cmd>> _version
 #+END_SRC

 outputs version number of ebench -application

 #+RESULTS: hello2-version
 : 0.0.10-SNAPSHOT


**** Help on a specific command: =??=

 #+BEGIN_SRC bash :eval no-eval :results output :exports both :noweb yes
 <<hello2Cmd>> ?? command=greet
 #+END_SRC

 #+RESULTS:
 #+begin_example
 greet - Say hello

 Hello -command just demonstrates simple menu action.

 It receives to parameters 'whom' and 'who' and prints greeting
 and increments 'greetCount' (just to demonstrate that Intrument
 MAY maintain internal state).


 :who: default value is of 'who' parameter is logged in user, its
 value is remembered between greetings

 :whom: object to be greeted

       whom  : Whom to greet?
        who  : Who is the greeter? Ret accepts default value: 

 Notice:
 - parameters MUST be given in the order listed above
 - parameters are optional and they MAY be left out
 #+end_example


**** Default value of a parameter

 Expect to see 'Hello world from $USER', where user gets default value
 from environment variable.

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 echo USER=$USER
 <<hello2Cmd>> greet whom="world" 
 #+END_SRC

 #+RESULTS:
 : USER=jj
 : Hello #1 to world from jj


 Expect to see 'Hello earth from moon', where default value
 ~os.environ['USER']~ is overridden with the value received from
 command line ~who="moon~:

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> greet whom="earth" who="moon"
 #+END_SRC

 #+RESULTS:
 : Hello #1 to earth from moon


**** Object state is managed and parameter values are remembered

 Making two CLI -greetings line demonstrates how object state is
 maintained (=variable ~greetCount~ incremented for each greeting).

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> greet whom="moon" who="earth" greet whom="sun"
 #+END_SRC

 #+RESULTS:
 : Hello #1 to moon from earth
 : Hello #2 to sun from earth


**** Use command line configuration for intialization

 Use command CLI switch ~--greetCount=61~ to initialize application,
 and expect to see greetings counted starting from 62:

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 echo USER=$USER
 <<hello2Cmd>> --greetCount=61 greet whom="the world"  greet whom="the sun"   greet whom="the moon"  
 #+END_SRC

 #+RESULTS:
 : USER=jj
 : Hello #62 to the world from jj
 : Hello #63 to the sun from jj
 : Hello #64 to the moon from jj


 
 
* Fin                                                              :noexport:

   # Local Variables:
   # org-confirm-babel-evaluate: nil
   # End:
   #


