* Hello World
:PROPERTIES:
:TOC:      :include all
:END:

This document presents two hello world examples:
1) stand alone Hello World
2) Hello World as instrument controllers, which can be integrated to
   work together with other instrument controllers on ~ebMenu~

:CONTENTS:
- [[#hello-world][Hello World]]
  - [[#stand-alone-hello-world---hellopy][Stand Alone Hello World - hello.py]]
    - [[#imports][Imports]]
    - [[#define-hello--function-and-parameter-prompt][Define hello -function and parameter prompt]]
    - [[#define-menu][Define menu]]
    - [[#wrap-hello-to-an-executable-script][Wrap hello to an executable script]]
    - [[#hellopy][Hello.py]]
    - [[#hello-interctive-usage][hello interctive usage]]
    - [[#hello-cli-usage][hello CLI usage]]
  - [[#hello-world-as-an-instrument-controller---hello2py][Hello World as an Instrument Controller - hello2.py]]
    - [[#define-instrument-controller-class--helloinstrument][Define Instrument Controller Class  HelloInstrument]]
    - [[#define-parameters-and-default-values-for-menu-action-hello][Define parameters and default values for menu action hello]]
    - [[#list-commands-and-help-commands][List commands and help commands]]
    - [[#define-application-menu][Define application menu]]
    - [[#create--run--function-for-executing-the-application][Create  run -Function for executing the application]]
    - [[#create-application-main-for-interactive-and-cli--use][Create application main for Interactive and CLI -use]]
    - [[#hello2-application][hello2 application]]
    - [[#running-hello2][Running hello2]]
      - [[#configuration-parameters-with---help][Configuration parameters with --help]]
      - [[#usage-help-and-listing-commands-with-][Usage help and listing commands with ?]]
      - [[#hidden-commands][Hidden commands]]
      - [[#help-on-a-specific-command-][Help on a specific command: ??]]
      - [[#default-value-of-a-parameter][Default value of a parameter]]
      - [[#object-state-is-managed-and-parameter-values-are-remembered][Object state is managed and parameter values are remembered]]
      - [[#use-command-line-configuration-for-intialization][Use command line configuration for intialization]]
:END:


** Stand Alone Hello World - ~hello.py~

*** Imports
    :PROPERTIES:
    :header-args:bash: :dir  examples/hello
    :END:

 Hello -example uses ~MenuCtrl~ class from ~ebench~ module

  #+name: import
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from ebench import MenuCtrl
  #+END_SRC

  #+RESULTS: import
  : Python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42) 
  : [GCC 9.3.0] on linux
  : Type "help", "copyright", "credits" or "license" for more information.

 and some basic infrastructure services from ~os~ module and command
 line options from ~absl~

  #+name: import-env
  #+BEGIN_SRC python :eval no-export :results output :noweb no :session *Python*
  import os
  from absl import app, flags, logging
  from absl.flags import FLAGS
  #+END_SRC

  #+RESULTS: import-env


*** Define ~hello~ -function and parameter prompt

 Define Python function ~hello~ with a parameter ~whom~, which gives
 whom to greet:

  #+name: hello
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  def hello( whom:str ):
      print( "Hello {}".format(whom))
  #+END_SRC

 For prompting ~"Whom to greet?"~ define a dictionary, which maps
 ~whom~ parameter to a promp presented to user in menu REPL -loop:

  #+name: helloPar
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  helloPar = {
     "whom": "Whom to greet?"
  }
  #+END_SRC



*** Define menu

 Define a menu command for invoking ~hello~ function and allowing user
 to quit the appplication with menu command ~MenuCtrl.MENU_QUIT~
 (mapped to letter ~q~).

 Menu is defined as dictionary mapping menu command to a 3-tuple. The
 tuple elements are 0: /prompt presented to user/, 1: /menu action
 parameters/, and 3: /function to execute the menu action/.

  #+name: menu
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

      mainMenu = {
          "hello"                 : ( "Say hello", helloPar, hello),
          MenuCtrl.MENU_QUIT      : MenuCtrl.MENU_QUIT_TUPLE,
      }
  #+END_SRC


*** Wrap hello to an executable script

 To create an executable script first define function ~_main~, which
 constructs ~MenuCtrl~ object and configures main prompt presented to
 user. Passing ~_arvg~ parameter to constructor allows application
 interactive and CLI usage.  Method ~setMenu~ configures menu presented
 user and application REPL cycle is executed within ~mainMenu()~
 -method.

  #+name: _main
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes
  def _main( _argv ):
      # configure logger
      logging.set_verbosity(FLAGS.debug)

      # Construct 'menuController' 
      menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]")
     
      # and configure menu
      menuController.setMenu(mainMenu)

      # start executing
      menuController.mainMenu()

  #+END_SRC

 Finalize application with following code, which basically calls
 ~_main~ after absl context is setup correctly.

  #+name: main
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  def main():
      try:
          app.run(_main)
      except SystemExit:
          pass
    
    
  if __name__ == '__main__':
      main()

  #+END_SRC


*** Hello.py


  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello/hello.py :noweb yes :shebang "#!/usr/bin/env python3" :exports none
  <<import>>

  <<import-env>>

  <<hello>>

  <<helloPar>>

  <<menu>>

  <<_main>>

  <<main>>

  #+END_SRC

 Complete ~hello~ example is shown below:

 #+BEGIN_SRC bash :eval no :results output :exports results
 cat examples/hello/hello.py
 #+END_SRC

 #+RESULTS:
 #+begin_example
 #!/usr/bin/env python3
 import ebench
 from ebench import MenuCtrl



 import os
 from absl import app, flags, logging
 from absl.flags import FLAGS

 def hello( whom:str ):
     print( "Hello {}".format(whom))

 helloPar = {
    "whom": "Whom to greet?"
 }


 mainMenu = {
     "hello"                 : ( "Say hello", helloPar, hello),
     MenuCtrl.MENU_QUIT      : ( "Exit", None, None),
 }

 def _main( _argv ):
     # global gSkooppi
     logging.set_verbosity(FLAGS.debug)

     cmdController = MenuCtrl()

     cmdController.mainMenu( _argv, menu=mainMenu, mainPrompt="[hello, q=quit]")






 def main():
     try:
         app.run(_main)
     except SystemExit:
         pass


 if __name__ == '__main__':
     main()
 #+end_example


*** =hello= interctive usage

 Interactive usage demonstrated using HERE-document. The following
 example prompts user whom to greet, and after the answer, ~moon~,
 greets the moon.

 #+BEGIN_SRC bash :eval no-export :results output :exports both
   cat <<EOF | examples/hello/hello.py
   hello
   moon
   q
   EOF
 #+END_SRC

 #+RESULTS:


*** =hello= CLI usage

 for Command line usage, menu command 'hello' is followed by key-value
 pair ~whom=World~. The result greets the world.

 #+BEGIN_SRC bash :eval no-export :results output :exports both
 examples/hello/hello.py hello whom=World
 #+END_SRC

 #+RESULTS:
 : Hello World


 :PROPERTIES:
 :TOC:      :include all
 :END:

 :CONTENTS:

 :END:


** Hello World as an Instrument Controller - ~hello2.py~ 

 Second Hello World  -version, ~hello2~, presents:
 - maintaining instrument state (in this example count number of greets
   made)
 - help to list commands 
 - more detailed help on menu commands
 - menu structuring using menu separator
 - hiding menu command from menu command list
 - default value for menu command parameter
 - proviso to integrate ~hello2~ to menu system ~ebMenu~ (to be
   document separately)

*** Define Instrument Controller Class  ~HelloInstrument~

 Add import for  ~Instrument~ class from ~ebench~:

  #+name: import2a
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from ebench import Instrument
  #+END_SRC

 and use it to derive ~HelloInstrument~ class. ~HelloInstrument~ counts
 number of greets made in variable ~greetCount~. Its initial value can
 be set in constructor.  Method ~sayHello~ prints out greeting and
 increments number of greets made in ~greetCount~.

  #+name: hello2
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
    class HelloInstrument(Instrument):

      def __init__(self, greetCount=0):
          self._greetCount = greetCount

      def greetCount(self, fake=0 ):
          """Access object state variable with API twist

          :fake: parameter used to demonstrate passing literal parameter
          value in API call

          :return: current 'greetCount' + 'fake'

          """

          return self._greetCount + int(fake)

      def sayHello( self, whom:str, who:str ):
          """Hello -command just demonstrates simple menu action.

          It receives to parameters 'whom' and 'who' and prints
          greeting. Defaulta value of 'who' parameter is logged user, and
          its value is remembered between hello commands

          Returns greeted 'whom' if greeter/who is not the same as
          greeted/whom.

          Incrementing greetCount demonstrates that Intrument MAY
          maintain internal state.

          """
          self._greetCount = self._greetCount + 1
          print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))
  #+END_SRC


*** Define parameters and default values for menu action ~hello~

 Dictionary ~helloPar~ names the the paramerters ~sayHello~ methods
 accepts, and maps these variable names from prompt string presented to
 user.

  #+name: helloPar2
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  greetPar = {
     "whom": "Whom to greet?",
     "who":  "Who is the greeter? Ret accepts default value: ",
  }
  #+END_SRC


 Dictionary ~defaults~ is used to provide default values to menu
 parameters. In this example, hello menu selection parameter ~who~ gets
 default value from environment variable ~$USER~.

 #+name: defaults
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

 defaults = {
 "greet" : {
              "who": os.environ['USER']
           }
 }
 #+END_SRC


*** List commands and help commands 

 Import ~usage~ and ~usageCommand~ for presenting usage instructions
 and help on menu selections.

  #+name: import2b
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from ebench import usage, usageCommand, version
  #+END_SRC


 Define application usage text. For this example we will define
 variable ~usageText~ with the following content

 #+name:usageText
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

   usageText = """

   This demo presents:

   - maintaining instrument state: counting number of greetings made

   - command 'hello' accepting two parameters, one of the parameters
     (whom) is prompted for every command call, the other paremeter (who)
     defaults to to login-name, and its value is rememebered from
     previous call

   - menu separator

   - help to list command (and to show this text)

   - more detailed help on menu commands

   - hidden command: _version

   - proviso for integrating ~hello2~ with ebMenu

   """


 #+END_SRC


*** Define application menu

 ~hello2~ -menu is divided into three sections 1) commands, 2) help,
 and 3) exiting:

  #+name: menu2
  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
    mainMenu = {

        # First section: application commands
        "Commands:"              : MenuCtrl.MENU_SEPATOR_TUPLE,
        "greet"                  : ( "Say hello", greetPar, helloController.sayHello ),

        # Second section: getting help
        "Help:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
        MenuCtrl.MENU_HELP       : ( "List commands", None,
                                   lambda : usage(cmd=os.path.basename(__file__)
                                                        , mainMenu=mainMenu
                                                        , synopsis="Demo hello v2"
                                                        , usageText=usageText )),
        MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                   lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),

        # Third section: exiting
        "Exit:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
        MenuCtrl.MENU_QUIT       : MenuCtrl.MENU_QUIT_TUPLE,

        # Hidden
        "_version"               : ("Version number", None, lambda **argv: print(version())),

    }

  #+END_SRC


*** Create  ~run~ -Function for executing the application

 ~run~ function instantiates ~HelloInstrument~, application menu
 (~mainMenu~ using placeholder ~<<menu2>>~), and creates
 ~menuController~. Call to ~menuController.mainMenu()~ which executes
 application [[https://codewith.mu/en/tutorials/1.1/repl][REPL]] (red-eval-print) -loop


 #+name: _run2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes

   def run( _argv, runMenu:bool = True, greetCount = 0  ):
        """Run hello2 as a standalone interactive or CLI application with the
        proviso to integrate 'hello2' with ~ebench.ebMenu~ tool.

        :_argv: list of command line arguments. In interactive mode, this
        is just the name of script. In CLI mode, name is followed by
        command line arguments

        :runMenu: defaults True = running standalone application. ebMenu
        sets this to 'False'.

        :greetCount: In this contrived example, 'greetCount' is the
        number greetings already made. It is passed to 'HelloInstrument'
        -constructor. For real world use, 'greetCount' represents
        parameters needed in instruments constructor.

        """
        helloController = HelloInstrument( greetCount = greetCount )

        <<menu2>>

        menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]", instrument=helloController )
        menuController.setMenu(menu=mainMenu, defaults=defaults)
        if runMenu: menuController.mainMenu()

        return menuController

  #+END_SRC

~_main~ calls ~hello.run()~ and passes command line configuration
parameter ~FLAGS.greetCount~ to ~run~ -function. After returning from
~run~, close ~menuController~ constructed.

 #+name: _main2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes

   def _main( _argv ):
       logging.set_verbosity(FLAGS.debug)

       # Start standalone application
       menuController = run( _argv, greetCount = FLAGS.greetCount )

       # q from menu or end of CLI parameters
       menuController.close()


  #+END_SRC

In ~main~ -function setup ~absl~  context and call run ~_main()~ function from above

#+name: _main2_main
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

  def main():
      try:
          app.run(_main)
      except SystemExit:
          pass
    
    
  if __name__ == '__main__':
      main()


#+END_SRC


*** Create application main for Interactive and CLI -use

Import ~run~ function from ~hello2~ -module and [[https://pypi.org/project/absl-py/][absl]] -services

#+name: hello2-import
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  from hello2 import run

  from absl import app, flags, logging
  from absl.flags import FLAGS
#+END_SRC


and define command line configuration parameter ~greetCount~ with initial value ~0~

#+name: hello2-configs
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
  flags.DEFINE_integer('greetCount', 0, "Initial number of greets already made")
#+END_SRC



*** hello2 application 

  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello2/hello2.py :noweb yes :shebang :exports none
  <<import>>

  <<import2a>>

  <<import2b>>

  <<import-env>>

  # --------------------------------------
  # Example instrument "HelloInstrument"

  <<hello2>>

  # --------------------------------------
  # Menu interagration

  <<helloPar2>>

  <<defaults>>

  <<helpers>>

  <<usageText>>

  # --------------------------------------
  # Application run && ebMenu integration

  <<_run2>>

  #+END_SRC


  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello2/hello2_main.py :noweb yes :shebang "#!/usr/bin/env python3" :exports none

  <<hello2-import>> 

  # --------------------------------------
  # Command line configurations

  <<hello2-configs>> 

  # --------------------------------------
  # Application main - call hello2.run()

  <<_main2>>

  <<_main2_main>>


  #+END_SRC

  #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello2/__init__.py :noweb yes :exports none
  #+END_SRC

 Complete hello2 -example is shown below

 #+BEGIN_SRC bash :eval no-export :results output :exports results
 cat examples/hello2/hello2.py
 #+END_SRC

 #+RESULTS:
 #+begin_example
 from ebench import MenuCtrl

 from ebench import Instrument

 from ebench import usage, usageCommand, version

 import os
 from absl import app, flags, logging
 from absl.flags import FLAGS

 # --------------------------------------
 # Example instrument "HelloInstrument"

 class HelloInstrument(Instrument):

   def __init__(self, greetCount=0):
       self._greetCount = greetCount

   def greetCount(self, fake=0 ):
       """Access object state variable with API twist

       :fake: parameter used to demonstrate passing literal parameter
       value in API call

       :return: current 'greetCount' + 'fake'

       """

       return self._greetCount + int(fake)

   def sayHello( self, whom:str, who:str ):
       """Hello -command just demonstrates simple menu action.

       It receives to parameters 'whom' and 'who' and prints
       greeting. Defaulta value of 'who' parameter is logged user, and
       its value is remembered between hello commands

       Returns greeted 'whom' if greeter/who is not the same as
       greeted/whom.

       Incrementing greetCount demonstrates that Intrument MAY
       maintain internal state.

       """
       self._greetCount = self._greetCount + 1
       print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))

 # --------------------------------------
 # Menu interagration

 greetPar = {
    "whom": "Whom to greet?",
    "who":  "Who is the greeter? Ret accepts default value: ",
 }


 defaults = {
 "greet" : {
              "who": os.environ['USER']
           }
 }




 usageText = """

 This demo presents:

 - maintaining instrument state: counting number of greetings made

 - command 'hello' accepting two parameters, one of the parameters
   (whom) is prompted for every command call, the other paremeter (who)
   defaults to to login-name, and its value is rememebered from
   previous call

 - menu separator

 - help to list command (and to show this text)

 - more detailed help on menu commands

 - hidden command: _version

 - proviso for integrating ~hello2~ with ebMenu

 """



 # --------------------------------------
 # Application run && ebMenu integration


 def run( _argv, runMenu:bool = True, greetCount = 0  ):
      """Run hello2 as a standalone interactive or CLI application with the
      proviso to integrate 'hello2' with ~ebench.ebMenu~ tool.

      :_argv: list of command line arguments. In interactive mode, this
      is just the name of script. In CLI mode, name is followed by
      command line arguments

      :runMenu: defaults True = running standalone application. ebMenu
      sets this to 'False'.

      :greetCount: In this contrived example, 'greetCount' is the
      number greetings already made. It is passed to 'HelloInstrument'
      -constructor. For real world use, 'greetCount' represents
      parameters needed in instruments constructor.

      """
      helloController = HelloInstrument( greetCount = greetCount )

      mainMenu = {

          # First section: application commands
          "Commands:"              : MenuCtrl.MENU_SEPATOR_TUPLE,
          "greet"                  : ( "Say hello", greetPar, helloController.sayHello ),

          # Second section: getting help
          "Help:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
          MenuCtrl.MENU_HELP       : ( "List commands", None,
                                     lambda : usage(cmd=os.path.basename(__file__)
                                                          , mainMenu=mainMenu
                                                          , synopsis="Demo hello v2"
                                                          , usageText=usageText )),
          MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                     lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),
          "_version"               : ("Version number", None, lambda **argv: print(version())),

          # Third section: exiting
          "Exit:"                  : MenuCtrl.MENU_SEPATOR_TUPLE,
          MenuCtrl.MENU_QUIT       : MenuCtrl.MENU_QUIT_TUPLE,


      }


      menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]", instrument=helloController )
      menuController.setMenu(menu=mainMenu, defaults=defaults)
      if runMenu: menuController.mainMenu()

      return menuController
 #+end_example

 Main -function are save in a separate file ~hello2_main.py~ to avoid
 conflicts in ~absl~ flags. 

 #+BEGIN_SRC bash :eval no-export :results output :exports results
 cat examples/hello2/hello2_main.py
 #+END_SRC

 #+RESULTS:
 #+begin_example
 #!/usr/bin/env python3
 from hello2 import run

 from absl import app, flags, logging
 from absl.flags import FLAGS 

 # --------------------------------------
 # Command line configurations

 flags.DEFINE_integer('greetCount', 0, "Initial number of greets already made") 

 # --------------------------------------
 # Application main - call hello2.run()


 def _main( _argv ):
     logging.set_verbosity(FLAGS.debug)

     # Start standalone application
     menuController = run( _argv, greetCount = FLAGS.greetCount )

     # q from menu or end of CLI parameters
     menuController.close()




 def main():
     try:
         app.run(_main)
     except SystemExit:
         pass


 if __name__ == '__main__':
     main()
 #+end_example

 Python needs an ampty file ~__init__.py~ saved along with ~hello2.py~ and ~hello2_main.py~ 
 #+BEGIN_SRC bash :eval no-export :results output :exports results
 cd examples/hello2
 ls -ltr | grep -v  __pycache__
 #+END_SRC

 #+RESULTS:
 : total 20
 : -rw-rw-r-- 1 jj jj 4335 huhti 27 12:22 hello2.py
 : -rwxr-xr-x 1 jj jj  705 huhti 27 12:22 hello2_main.py
 : -rw-rw-r-- 1 jj jj    1 huhti 27 12:22 __init__.py


*** Running ~hello2~

In the examples below, ~<<hello2Cmd>>~ refers to following python
module:

#+name: hello2Cmd
#+BEGIN_SRC cpp :exports code
examples/hello2/hello2_main.py
#+END_SRC


**** Configuration parameters with ~--help~

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> --help
 #+END_SRC

 #+RESULTS:
 #+begin_example

        USAGE: examples/hello2/hello2_main.py [flags]
 flags:

 examples/hello2/hello2_main.py:
   --greetCount: Initial number of greets already made
     (default: '0')
     (an integer)

 Try --helpfull to get a list of all flags.
 #+end_example




**** Usage help and listing commands with =?=
 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> ?
 #+END_SRC

 #+RESULTS:
 #+begin_example
 hello2.py: Demo hello v2

 Usage: hello2.py [options] [commands and parameters] 

 Commands:

 ---------- Commands:  ----------
           greet  : Say hello
 ----------   Help:    ----------
               ?  : List commands
              ??  : List command parameters
 ----------   Exit:    ----------
               q  : Exit


 This demo presents:

 - maintaining instrument state: counting number of greetings made

 - command 'hello' accepting two parameters, one of the parameters
   (whom) is prompted for every command call, the other paremeter (who)
   defaults to to login-name, and its value is rememebered from
   previous call

 - menu separator

 - help to list command (and to show this text)

 - more detailed help on menu commands

 - hidden command: _version

 - proviso for integrating ~hello2~ with ebMenu


 #+end_example


**** Hidden commands

 Notice command ~_version~ is not show in commands list presented in
 previous chapter. However, running

 #+name: hello2-version
 #+BEGIN_SRC bash :eval no-export :results output :exports both :noweb yes
 <<hello2Cmd>> _version
 #+END_SRC

 outputs version number of ebench -application

 #+RESULTS: hello2-version
 : 0.0.10-SNAPSHOT


**** Help on a specific command: =??=

 #+BEGIN_SRC bash :eval no-eval :results output :exports both :noweb yes
 <<hello2Cmd>> ?? command=greet
 #+END_SRC

 #+RESULTS:
 #+begin_example
 greet - Say hello

 Hello -command just demonstrates simple menu action.

 It receives to parameters 'whom' and 'who' and prints
 greeting. Defaulta value of 'who' parameter is logged user, and
 its value is remembered between hello commands

 Returns greeted 'whom' if greeter/who is not the same as
 greeted/whom.

 Incrementing greetCount demonstrates that Intrument MAY
 maintain internal state.

       whom  : Whom to greet?
        who  : Who is the greeter? Ret accepts default value: 

 Notice:
 - parameters MUST be given in the order listed above
 - parameters are optional and they MAY be left out
 #+end_example


**** Default value of a parameter

 Expect to see 'Hello world from $USER', where user gets default value
 from environment variable.

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 echo USER=$USER
 <<hello2Cmd>> greet whom="world" 
 #+END_SRC

 #+RESULTS:
 : USER=jj
 : Hello #1 to world from jj


 Expect to see 'Hello world from moon', where default value is
 overridden on command line.

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes
 <<hello2Cmd>> greet whom="world" who="moon"
 #+END_SRC

 #+RESULTS:
 : Hello #1 to world from moon


**** Object state is managed and parameter values are remembered

 Making two CLI -greetings line demonstrates how object state is
 maintained (=variable ~greetCount~ increment for each greeting).

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 <<hello2Cmd>> greet whom="moon" who="earth" greet whom="sun"
 #+END_SRC

 #+RESULTS:
 : Hello #1 to moon from earth
 : Hello #2 to sun from earth


**** Use command line configuration for intialization

 Use command CLI switch ~--greetCount=61~ to initialize application,
 and expect to see greetings counted starting from 62:

 #+BEGIN_SRC bash :eval no-export :results output :noweb yes :exports both
 echo USER=$USER
 <<hello2Cmd>> --greetCount=61 greet whom="World"  greet whom="the sun"   greet whom="the moon"  
 #+END_SRC

 #+RESULTS:
 : USER=jj
 : Hello #62 to World from jj
 : Hello #63 to the sun from jj
 : Hello #64 to the moon from jj


 
 
* Fin                                                              :noexport:

   # Local Variables:
   # org-confirm-babel-evaluate: nil
   # End:
   #


