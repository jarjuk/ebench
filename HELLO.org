
* Basic hello  world

** Imports
   :PROPERTIES:
   :header-args:bash: :dir  examples/hello
   :END:

Hello -example uses ~MenuCtrl~ class from ~ebench~ module

 #+name: import
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 from ebench import MenuCtrl
 #+END_SRC

 #+RESULTS: import
 : Python 3.9.1 | packaged by conda-forge | (default, Jan 10 2021, 02:55:42) 
 : [GCC 9.3.0] on linux
 : Type "help", "copyright", "credits" or "license" for more information.

and some basic infrastructure services from ~os~ module and command
line options from ~absl~

 #+name: import-env
 #+BEGIN_SRC python :eval no-export :results output :noweb no :session *Python*
 import os
 from absl import app, flags, logging
 from absl.flags import FLAGS
 #+END_SRC

 #+RESULTS: import-env


** Define hello

Define Python function ~ hello~ accepts parameter ~whom~ to be
greeted:

 #+name: hello
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 def hello( whom:str ):
     print( "Hello {}".format(whom))
 #+END_SRC

For prompting ~"Whom to greet?"~ define a dictionary, which map ~whom~
parameter to the promp:

 #+name: helloPar
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 helloPar = {
    "whom": "Whom to greet?"
 }
 #+END_SRC


** Define menu

Define a menu strcuture for invoking ~hello~ function and allowing
user to quit the appplication with menu command ~q~ (which
~MenuCtrl.MENU_QUIT~ map to.

Menu is defined as dictionary mapping menu command to a 3-tuple. The
tuple elements are 0: prompt presented to user, 1: menu action
parameters (for the hello example using ~helloPar~ defined above), and
2: function to execute the menu action.


 #+name: menu
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

     mainMenu = {
         "hello"                 : ( "Say hello", helloPar, hello),
         MenuCtrl.MENU_QUIT      : ( "Exit", None, None),
     }
 #+END_SRC

** Wrap hello to an executable script

To create an executable script first define function ~_main~, which
constructs ~MenuCtrl~ object and configures main prompt presented to
user. Passing ~_arvg~ parameter to constructor allows application
interactive and CLI usage.  Method ~setMenu~ configures menu presented
user and application REPL cycle is executed within ~mainMenu()~
-method.

 #+name: _main
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes
 def _main( _argv ):
     # configure logger
     logging.set_verbosity(FLAGS.debug)

     # Construct 'menuController' 
     menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]")
     
     # and configure menu
     menuController.setMenu(mainMenu)

     # start executing
     menuController.mainMenu()

 #+END_SRC

Finalize application with following code, which basically calls
~_main~ after absl context is setup correctly.

 #+name: main
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 def main():
     try:
         app.run(_main)
     except SystemExit:
         pass
    
    
 if __name__ == '__main__':
     main()

 #+END_SRC

** Hello.py


 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello/hello.py :noweb yes :shebang "#!/usr/bin/env python3" :export none
 <<import>>

 <<import-env>>

 <<hello>>

 <<helloPar>>

 <<menu>>

 <<_main>>

 <<main>>

 #+END_SRC

Complete ~hello~ example is shown below:

#+BEGIN_SRC bash :eval no :results output :exports results
cat examples/hello/hello.py
#+END_SRC

#+RESULTS:
#+begin_example
#!/usr/bin/env python3
import ebench
from ebench import MenuCtrl



import os
from absl import app, flags, logging
from absl.flags import FLAGS

def hello( whom:str ):
    print( "Hello {}".format(whom))

helloPar = {
   "whom": "Whom to greet?"
}


mainMenu = {
    "hello"                 : ( "Say hello", helloPar, hello),
    MenuCtrl.MENU_QUIT      : ( "Exit", None, None),
}

def _main( _argv ):
    # global gSkooppi
    logging.set_verbosity(FLAGS.debug)

    cmdController = MenuCtrl()

    cmdController.mainMenu( _argv, menu=mainMenu, mainPrompt="[hello, q=quit]")






def main():
    try:
        app.run(_main)
    except SystemExit:
        pass


if __name__ == '__main__':
    main()
#+end_example


** =hello= interctive usage

Interactive usage demonstrated using HERE-document. The following
example prompts user whom to greet, and after the answer, ~moon~,
greets the moon.

#+BEGIN_SRC bash :eval no-export :results output :exports both
  cat <<EOF | examples/hello/hello.py
  hello
  moon
  q
  EOF
#+END_SRC

#+RESULTS:
: [hello, q=quit] > Whom to greet? > Hello moon
: [hello, q=quit] > 


** =hello= CLI usage

for Command line usage, menu command 'hello' is followed by key-value
pair ~whom=World~. The result greets the world.

#+BEGIN_SRC bash :eval no-export :results output :exports both
examples/hello/hello.py hello whom=World
#+END_SRC

#+RESULTS:
: Hello World



* Hello extended 

Second hello version, ~hello2~ presents:
- maintaining instrument state (in this example count number of greets
  made)
- help to list commands 
- more detailed help on menu commands
- menu structuring using menu separator
- hiding menu command from menu command list
- default value for menu command parameter
- proviso to integrate ~hello2~ to menu system ~ebMenu~ (to be
  document separately)

** Hello2

Add import for  ~Instrument~ class from ~ebench~:

 #+name: import2a
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 from ebench import Instrument
 #+END_SRC

and use it to derive ~HelloInstrument~ class. ~HelloInstrument~ counts
number of greets made in variable ~greetCount~. Its initial value can
be set in constructor.  Method ~sayHello~ prints out greeting and
increments number of greets made in ~greetCount~.

 #+name: hello2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
   class HelloInstrument(Instrument):

     def __init__(self, greetCount=0):
         self._greetCount = greetCount

     def greetCount(self, fake=0 ):
         """Access object state variable with API twist

         :fake: parameter used to demonstrate passing literal parameter
         value in API call

         :return: current 'greetCount' + 'fake'

         """

         return self._greetCount + int(fake)

     def sayHello( self, whom:str, who:str ):
         """Hello -command just demonstrates simple menu action.

         It receives to parameters 'whom' and 'who' and prints
         greeting. Defaulta value of 'who' parameter is logged user, and
         its value is remembered between hello commands

         Returns greeted 'whom' if greeter/who is not the same as
         greeted/whom.

         Incrementing greetCount demonstrates that Intrument MAY
         maintain internal state.

         """
         self._greetCount = self._greetCount + 1
         print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))
 #+END_SRC


** Menu acttion parameter with default value

Dictionary ~helloPar~ names the the paramerters ~sayHello~ methods
accepts, and maps these variable names from prompt string presented to
user.

 #+name: helloPar2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 helloPar = {
    "whom": "Whom to greet?",
    "who":  "Who is the greeter? Ret accepts default value: ",
 }
 #+END_SRC


Dictionary ~defaults~ is used to provide default values to menu
parameters. In this example, hello menu selection parameter ~who~ gets
default value from environment variable ~$USER~.

#+name: defaults
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

defaults = {
"hello" : {
             "who": os.environ['USER']
          }
}
#+END_SRC


** List commands and help commands 

Import ~usage~ and ~usageCommand~ for presenting usage instructions
and help on menu selections.

 #+name: import2b
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
 from ebench import usage, usageCommand, version
 #+END_SRC


Define application usage text. For this example we will define
variable ~usageText~ with the following content

#+name:usageText
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python*

  usageText = """

  This demo presents:

  - maintaining instrument state: counting number of greetings made

  - command 'hello' accepting two parameters, one of the parameters
    (whom) is prompted for every command call, the other paremeter (who)
    defaults to to login-name, and its value is rememebered from
    previous call

  - menu separator

  - help to list command (and to show this text)

  - more detailed help on menu commands

  - hidden command: _version

  """


#+END_SRC


** Define application menu

Hello menu2 is presented in three sections,

 #+name: menu2
 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python*
   mainMenu = {

       # First section: application commands
       "Commands:"              : ( None, None, None),
       "hello"                  : ( "Say hello", helloPar, hello.sayHello ),

       # Second section: getting help
       "Help:"                  : ( None, None, None),
       MenuCtrl.MENU_HELP       : ( "List commands", None,
                                  lambda : usage(cmd=os.path.basename(__file__)
                                                       , mainMenu=mainMenu
                                                       , synopsis="Demo hello v2"
                                                       , usageText=usageText )),
       MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                  lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),
       "_version"               : ("Version number", None, lambda **argv: print(version())),

       # Third section: exiting
       "Exit:"                  : ( None, None, None),
       MenuCtrl.MENU_QUIT       : ("Exit", None, None),

   }

 #+END_SRC


** Running application

Application ~_main~ calls ~run~ method, which instantiates
~HelloInstrument~, application menu and creates ~menuController~,
which executes application REPL (red-eval-print) -loop

*Note*: proviso for intergrating ~hello2~ to ~ebMenu~ application
- ~run~ method constructs ~hello~ object for ~HelloInstrument~ and
  passes it to ~menuController~ object created for ~MenuCtrl~ class
- ~run~ -method returns ~menuController~ object it has constructed
- ~run~ -method uses boolean parameter ~runMenu~ guarding
  ~menuController.mainMenu()~ which executes application REPL -loop
- closing menu ~menuController~ is done in ~_main~ after returning
  from ~run~ method


#+name: _main2
#+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :noweb yes

def run( _argv, runMenu:bool = True, greetCount = 0  ):
     hello = HelloInstrument( greetCount = greetCount )

     <<menu2>>

     menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]", instrument=hello )
     menuController.setMenu(menu=mainMenu, defaults=defaults)
     if runMenu: menuController.mainMenu()

     return menuController

def _main( _argv ):
     # global gSkooppi
    logging.set_verbosity(FLAGS.debug)
    menuController = run( _argv )
    menuController.close()

 #+END_SRC

 #+RESULTS: _main


** hello2 application 

 #+BEGIN_SRC python :eval no :results output :noweb no :session *Python* :tangle examples/hello/hello2.py :noweb yes :shebang "#!/usr/bin/env python3" :exports none
 <<import>>
 <<import2a>>

 <<import2b>>

 <<import-env>>

 # --------------------------------------
 # Example instrument "HelloInstrument"

 <<hello2>>

 # --------------------------------------
 # Menu interagration

 <<helloPar2>>

 <<defaults>>

 <<helpers>>

 <<usageText>>

 # --------------------------------------
 # Application main && ebMenu integration

 <<_main2>>

 <<main>>

 #+END_SRC

Complete hello2 -example is shown below

#+BEGIN_SRC bash :eval no-export :results output :exports results
cat examples/hello/hello2.py
#+END_SRC

#+RESULTS:
#+begin_example
#!/usr/bin/env python3
from ebench import MenuCtrl
from ebench import Instrument

from ebench import usage, usageCommand

import os
from absl import app, flags, logging
from absl.flags import FLAGS

# --------------------------------------
# Example instrument "HelloInstrument"

class HelloInstrument(Instrument):

  def __init__(self, greetCount=0):
      self._greetCount = greetCount

  def greetCount(self, fake=0 ):
      """Access object state variable with API twist

      :fake: parameter used to demonstrate passing literal parameter
      value in API call

      :return: current 'greetCount' + 'fake'

      """

      return self._greetCount + int(fake)

  def sayHello( self, whom:str, who:str ):
      """Hello -command just demonstrates simple menu action.

      It receives to parameters 'whom' and 'who' and prints
      greeting. Defaulta value of 'who' parameter is logged user, and
      its value is remembered between hello commands

      Returns greeted 'whom' if greeter/who is not the same as
      greeted/whom.

      Incrementing greetCount demonstrates that Intrument MAY
      maintain internal state.

      """
      self._greetCount = self._greetCount + 1
      print( "Hello #{} to {} from {}".format(self._greetCount, whom, who))

# --------------------------------------
# Menu interagration

helloPar = {
   "whom": "Whom to greet?",
   "who":  "Who is the greeter? Ret accepts default value: ",
}


defaults = {
"hello" : {
             "who": os.environ['USER']
          }
}




usageText = """

This demo presents:

- maintaining instrument state: counting number of greetings made

- command 'hello' accepting two parameters, one of the parameters
  (whom) is prompted for every command call, the other paremeter (who)
  defaults to to login-name, and its value is rememebered from
  previous call

- menu separator

- help to list command (and to show this text)

- more detailed help on menu commands

- hidden command: _version

"""



# --------------------------------------
# Application main && ebMenu integration


def run( _argv, runMenu:bool = True, greetCount = 0  ):
     hello = HelloInstrument( greetCount = greetCount )

     mainMenu = {
     
         # First section: application commands
         "Commands:"              : ( None, None, None),
         "hello"                  : ( "Say hello", helloPar, hello.sayHello ),
     
         # Second section: getting help
         "Help:"                  : ( None, None, None),
         MenuCtrl.MENU_HELP       : ( "List commands", None,
                                    lambda : usage(cmd=os.path.basename(__file__)
                                                         , mainMenu=mainMenu
                                                         , synopsis="Demo hello v2"
                                                         , usageText=usageText )),
         MenuCtrl.MENU_CMD_PARAM  : ( "List command parameters", MenuCtrl.MENU_HELP_CMD_PARAM,
                                    lambda **argV: usageCommand(mainMenu=mainMenu, **argV)),
         "_version"               : ("Version number", None, lambda **argv: print(ebench.version())),
     
         # Third section: exiting
         "Exit:"                  : ( None, None, None),
         MenuCtrl.MENU_QUIT       : ("Exit", None, None),
     
     }
     

     menuController = MenuCtrl(args=_argv,prompt="[hello, q=quit]", instrument=hello )
     menuController.setMenu(menu=mainMenu, defaults=defaults)
     if runMenu: menuController.mainMenu()

     return menuController

def _main( _argv ):
     # global gSkooppi
    logging.set_verbosity(FLAGS.debug)
    menuController = run( _argv )
    menuController.close()


def main():
    try:
        app.run(_main)
    except SystemExit:
        pass


if __name__ == '__main__':
    main()
#+end_example


** Running it

*** Usage help and listing commands with =?=
#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py ?
#+END_SRC

#+RESULTS:
#+begin_example
hello2.py: Demo hello v2

Usage: hello2.py [options] [commands and parameters] 

Commands:

---------- Commands:  ----------
          hello  : Say hello
----------   Help:    ----------
              ?  : List commands
             ??  : List command parameters
----------   Exit:    ----------
              q  : Exit


This demo presents:

- maintaining instrument state: counting number of greetings made

- command 'hello' accepting two parameters, one of the parameters
  (whom) is prompted for every command call, the other paremeter (who)
  defaults to to login-name, and its value is rememebered from
  previous call

- menu separator

- help to list command (and to show this text)

- more detailed help on menu commands

- hidden command: _version


#+end_example


*** Hidden commands

Notice command ~_version~ is not show in commands list presented in
previous chapter. However, running

#+name: hello2-version
#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py _version
#+END_SRC

outputs version number of ebench -application

#+RESULTS: hello2-version
: 0.0.10-pre2



*** Help on a specific command: =??=


#+BEGIN_SRC bash :eval no :results output
examples/hello/hello2.py ?? command=hello
#+END_SRC

#+RESULTS:
#+begin_example
hello - Say hello

Hello -command just demonstrates simple menu action.

It receives to parameters 'whom' and 'who' and prints
greeting. Defaulta value of 'who' parameter is logged user,
and its value is remembered between hello commands

Returns greeted 'whom' if greeter/who is not the same as
greeted/whom.

Notice, how

      whom  : Whom to greet?
       who  : Who is the greeter? Ret accepts default value: 

Notice:
- parameters MUST be given in the order listed above
- parameters are optional and they MAY be left out
#+end_example


*** Default value of a parameter

Expect to see 'Hello world from $USER', where user gets default value
from environment variable.

#+BEGIN_SRC bash :eval no-export :results output
echo USER=$USER
examples/hello/hello2.py hello whom="world" 
#+END_SRC

#+RESULTS:
: USER=jj
: Hello #1 to world from jj

Expect to see 'Hello world from moon', where default value is
overridden on command line.

#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py hello whom="world" who="moon"
#+END_SRC

#+RESULTS:
: Hello #1 to world from moon


*** Object state is managed and parameter values are remembered

Greeting twice, demostrates how object state gets in maintained
(variable ~greetCount~ increment for each greeting ), for ~hello2~
execution. Thi example also shows, how, for the second greeting,
variable ~who~ retains its previous value given to the first greeting.

#+BEGIN_SRC bash :eval no-export :results output
examples/hello/hello2.py hello whom="world" who="earth" hello whom="sun"
#+END_SRC

#+RESULTS:
: Hello #1 to world from earth
: Hello #2 to sun from earth


* Fin                                                              :noexport:

** Emacs variables

   #+RESULTS:

   # Local Variables:
   # org-confirm-babel-evaluate: nil
   # End:
   #
   # Muuta 
   # eval: (cdlatex-mode)
   #
   # Local ebib:
   # org-ref-default-bibliography: "./HELLO.bib"
   # org-ref-bibliography-notes: "./HELLO-notes.org"
   # org-ref-pdf-directory: "./pdf/"
   # org-ref-notes-directory: "."
   # bibtex-completion-notes-path: "./HELLO-notes.org"
   # ebib-preload-bib-files: ("./HELLO.bib")
   # ebib-notes-file: ("./HELLO-notes.org")
   # reftex-default-bibliography: ("./HELLO.bib")



